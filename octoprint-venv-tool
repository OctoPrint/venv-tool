#!/bin/env python3

import argparse
import configparser
import glob
import json
import os
import shutil
import subprocess
import sys
import tempfile
import typing
import urllib.request

MIN_PYTHON_VERSION = "3.9"
MAX_PYTHON_VERSION = None
DEFAULT_PACKAGES = ("pip", "wheel", "OctoPrint")

#--- Helpers --------------------------------------------------------

def _print_cli_result(result):
    print("---")
    print("stdout: " + result.stdout.decode("utf-8"))
    print("---")
    print("stderr: " + result.stderr.decode("utf-8"))
    print("---")


def _cli(*args, silent: bool = False):
    if not silent:
        print(f"Running: {' '.join(args)}")

    result = None
    try:
        result = subprocess.run(args, capture_output=True, check=True)
    except Exception:
        if result:
            _print_cli_result(result)
        raise

    if not silent:
        _print_cli_result(result)
        print("... done.")

    return result


def _pip_install(python: str, package: str, update=False) -> None:
    print(f"Installing {package}...")
    if update:
        _cli(python, "-m", "pip", "install", "-U", package)
    else:
        _cli(python, "-m", "pip", "install", package)

#--- Plugin Export --------------------------------------------------

REPO_URL = "https://plugins.octoprint.org/plugins.json"

class CaseSensitiveConfigParser(configparser.ConfigParser):
    optionxform = staticmethod(str)

def ids_for_txt(path: str) -> typing.Optional[typing.List[str]]:
    parser = CaseSensitiveConfigParser()
    try:
        parser.read(path)
        if "octoprint.plugin" in parser:
            return list(parser["octoprint.plugin"].keys())
    except configparser.ParsingError as exc:
        print(f"Parsing error while reading {path}: {exc}", file=sys.stderr)

def ids_for_venv(venv: str) -> None:
    ids = set()

    entries = glob.glob(venv + "/**/site-packages/*.dist-info/entry_points.txt", recursive=True)
    for entry in entries:
        plugin_ids = ids_for_txt(entry)
        if plugin_ids:
            ids.update(plugin_ids)
    
    return ids

def fetch_repo_plugins() -> dict:
    plugins = {}

    try:
        with urllib.request.urlopen(REPO_URL) as f:
            repo = json.loads(f.read().decode("utf-8"))
    except Exception as exc:
        raise RuntimeError("Error fetching plugins from repository") from exc

    for entry in repo:
        plugins[entry["id"]] = entry

    return plugins

def create_export(venv, output = None) -> None:
    ids = ids_for_venv(venv)

    repo_plugins = fetch_repo_plugins()

    export = []
    for key in ids:
        data = repo_plugins.get(key)
        if not data:
            print(f"Plugin '{key}' is not available on the repository, skipping", file=sys.stderr)
            continue
        export.append({
            "key": key,
            "name": data["title"],
            "url": data["homepage"],
            "archive": data["archive"]
        })
    
    json_str = json.dumps(export)
    if not output:
        print(json_str)
    else:
        with open(output, "w", encoding="utf-8") as f:
            f.write(json_str)

#--- Plugins install from export ------------------------------------

def install_export(venv: str, export: str) -> None:
    python = None
    for option in ("bin", "scripts"):
        p = os.path.join(venv, option, "python")
        if os.path.exists(p):
            python = p
    
    if not python:
        raise RuntimeError(f"Could not determine python command for venv {venv}")

    with open(export, "r", encoding="utf-8") as f:
        plugins = json.load(f)
    
    if not plugins:
        return

    for plugin in plugins:
        try:
            _pip_install(python, plugin["archive"])
        except RuntimeError as exc:
            print(f"Installing plugin {plugin['key']} from {plugin['archive']} failed: {exc}", file=sys.stderr)

#--- Create venv ----------------------------------------------------

def _validate_python(python):
    from packaging.version import parse as parse_version

    result = _cli(python, "-c", "import sys; v=sys.version_info; print(f'{v.major}.{v.minor}.{v.micro}')", silent=True)

    python_version = parse_version(result.stdout.decode("utf-8").strip())
    if (MIN_PYTHON_VERSION and python_version < parse_version(MIN_PYTHON_VERSION)) or (MAX_PYTHON_VERSION and python_version > parse_version(MAX_PYTHON_VERSION)):
        raise RuntimeError(f"Python at {python} has version {str(python_version)} which is unsupported")

    print(f"Python at {python} has version {str(python_version)}")
    return python_version


def create_venv(venv, python=None, export=None):
    if python is None:
        python = sys.executable
    
    _validate_python(python)

    print(f"Creating venv from {python}...")
    _cli(python, "-m", "venv", venv)

    if DEFAULT_PACKAGES:
        venv_python = None
        for option in ("bin", "scripts"):
            p = os.path.join(venv, option, "python")
            if os.path.exists(p):
                venv_python = p

        for package in DEFAULT_PACKAGES:
            _pip_install(venv_python, package, update=True)

    if export:
        install_export(venv, export)

#--- Recreate venv --------------------------------------------------

def backup_venv(venv, backup=None):
    if backup is None:
        backup = f"{venv}.bck"
    os.rename(venv, backup)

def recreate_venv(venv, python=None, backup=None):
    if backup is None:
        backup = f"{venv}.bck"

    with tempfile.NamedTemporaryFile(delete=False) as f:
        try:
            f.close()

            print(f"Creating plugin export at {f.name}...")
            create_export(venv, output=f.name)

            print(f"Backing up existing venv to {backup}...")
            backup_venv(venv, backup=backup)
            input("hit key to continue...")

            print(f"Creating new venv at {venv} using python at {python}")
            create_venv(venv, python=python)

            print(f"Installing plugin export {f.name} into recreated venv {venv}...")
            install_export(venv, export=f.name)
        except Exception:
            input("error, hit enter to continue")
            if os.path.exists(backup):
                print("Restoring backed up venv...")
                if os.path.exists(venv):
                    shutil.rmtree(venv)
                os.rename(backup, venv)
            raise
        finally:
            if os.path.exists(f.name):
                os.remove(f.name)

#--- Main -----------------------------------------------------------

def get_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Various tools for OctoPrint's venvs")
    subparsers = parser.add_subparsers(dest="subcommand")

    # parser for export-plugins command
    export_parser = subparsers.add_parser("export-plugins", help="Export a list of all OctoPrint plugins installed into the venv that are available on the repo.")
    export_parser.add_argument("venv", type=str, help="path of the venv")
    export_parser.add_argument("--output", "-o", type=str, help="optional path for the export, if unset stdout will be used", default=None)

    # parser for install-plugins command
    install_parser = subparsers.add_parser("install-plugins", help="Install plugins from an export into a provided venv.")
    install_parser.add_argument("export", type=str, help="path of the export")
    install_parser.add_argument("venv", type=str, help="path of the venv")

    # parser for create-venv command
    create_parser = subparsers.add_parser("create-venv", help="Create an OctoPrint venv, installing an optional plugin export")
    create_parser.add_argument("--export", type=str, help="path of the export, optional", default=None)
    create_parser.add_argument("--python", type=str, help="python binary to use for creating the venv, optional, if not provided the version used to run the script will be used", default=None)
    create_parser.add_argument("venv", type=str, help="path of the venv")

    # parser for recreate-venv command
    recreate_parser = subparsers.add_parser("recreate-venv", help="Recreate an OctoPrint venv, attempt to migrate all plugins")
    recreate_parser.add_argument("--python", type=str, help="python binary to use for creating the venv, optional, if not provided the version used to run the script will be used", default=None)
    recreate_parser.add_argument("venv", type=str, help="path of the venv")

    return parser

if __name__ == "__main__":
    parser = get_parser()

    params = sys.argv
    if params[0].endswith("python"):
        params = params[1:]
    args = parser.parse_args(params[1:])

    subcommand = args.subcommand
    try:
        if subcommand == "export-plugins":
            create_export(args.venv, args.output)
        elif subcommand == "install-plugins":
            install_export(args.venv, args.export)
        elif subcommand == "create-venv":
            create_venv(args.venv, python=args.python, export=args.export)
        elif subcommand == "recreate-venv":
            recreate_venv(args.venv, python=args.python)
    except Exception as exc:
        print(f"Error running {subcommand}: {exc}", file=sys.stderr)
        sys.exit(-2)
